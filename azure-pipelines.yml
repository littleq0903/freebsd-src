trigger:
- main

# Define a parameter for the architecture
parameters:
- name: arch
  displayName: 'Architecture'
  type: string
  default: 'amd64'
  values:
    - 'amd64'
    - 'arm'
    - 'arm64'
    - 'i386'
    - 'powerpc'
    - 'powerpc64'
    - 'powerpc64le'
    - 'riscv'

variables:
  buildId: $(Build.BuildId)  # Assign the build ID to a variable

jobs:
- job: Build_OS_Image
  displayName: 'Build OS Image Job'
  timeoutInMinutes: 0  # Set global timeout to unlimited
  pool:
    name: BSD-Pool

  steps:
  - script: |
      sudo cp -v -R $(Build.SourcesDirectory)/** /usr/src
    displayName: 'Copy source code to /usr/src'

  # Set the architecture-specific variables directly in the steps
  - script: |
      TARGET_ARCH="amd64"  # Default
      if [[ '${{ parameters.arch }}' == 'amd64' ]]; then
        TARGET_ARCH="amd64"
      elif [[ '${{ parameters.arch }}' == 'arm' ]]; then
        TARGET_ARCH="armv7"
      elif [[ '${{ parameters.arch }}' == 'arm64' ]]; then
        TARGET_ARCH="aarch64"
      elif [[ '${{ parameters.arch }}' == 'i386' ]]; then
        TARGET_ARCH="i386"
      elif [[ '${{ parameters.arch }}' == 'powerpc' ]]; then
        TARGET_ARCH="powerpc"
      elif [[ '${{ parameters.arch }}' == 'powerpc64' ]]; then
        TARGET_ARCH="powerpc64"
      elif [[ '${{ parameters.arch }}' == 'powerpc64le' ]]; then
        TARGET_ARCH="powerpc64le"
      elif [[ '${{ parameters.arch }}' == 'riscv' ]]; then
        TARGET_ARCH="riscv64"
      fi
      
      # Export TARGET_ARCH as a pipeline variable for later steps
      echo "##vso[task.setvariable variable=TARGET_ARCH]$TARGET_ARCH"

      # Run the build with the resolved TARGET and TARGET_ARCH
      #sudo make -j$(sysctl -n kern.smp.cpus) -DWITHOUT_CLEAN=yes TARGET=${{ parameters.arch }} TARGET_ARCH=$TARGET_ARCH buildworld buildkernel
    displayName: 'Build world and kernel'

  - script: |
      # Build Azure image
      cd /usr/src/release
      sudo make CLOUDWARE=AZURE -DWITH_CLOUDWARE TARGET=${{ parameters.arch }} TARGET_ARCH=$TARGET_ARCH cw-azure
    displayName: 'Build Azure image'

  - task: PublishPipelineArtifact@1
    inputs:
      targetPath: '/usr/obj/usr/src/${{ parameters.arch }}.$(TARGET_ARCH)/release/azure.ufs.vhdf'
      artifactName: 'azure-image'
      publishLocation: 'pipeline'
    displayName: 'Publish Azure image artifact'

- job: Upload_Image_to_Azure_Community_Gallery
  displayName: 'Upload image to Azure Community Image Gallery'
  pool:
    name: Default
  steps:
  - task: DownloadPipelineArtifact@2
    inputs:
      artifactName: 'azure-image'
    displayName: 'Download Azure image artifact'

  - task: AzureCLI@2
    inputs:
      azureSubscription: '8f5d9c09-fe03-4887-968e-f797aa249c7b'  # Replace with your Azure service connection name
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        set -e  # Exit on any error

        # Variables (replace these with your actual values)
        RESOURCE_GROUP="yuas-bsd-rg"
        LOCATION="eastus"
        GALLERY_NAME="FreeBSDTestingGalleryYuas"
        IMAGE_DEFINITION="FreeBSD-14.0-Testing"
        IMAGE_VERSION="1.0.$(buildId)"
        PUBLISHER="ColinSuMSFT"
        OFFER="FREEBSD_14"
        SKU="14.0-Testing"
        STORAGE_ACCOUNT="yuassa$(date +%s)"  # Unique storage account name
        CONTAINER_NAME="vhds"

        # Create resource group if it doesn't exist
        az group create --name $RESOURCE_GROUP --location $LOCATION

        # Create storage account
        az storage account create \
          --name $STORAGE_ACCOUNT \
          --resource-group $RESOURCE_GROUP \
          --location $LOCATION \
          --sku Standard_LRS

        # Get storage account key
        STORAGE_KEY=$(az storage account keys list \
          --account-name $STORAGE_ACCOUNT \
          --resource-group $RESOURCE_GROUP \
          --query '[0].value' -o tsv)

        # Create container
        az storage container create \
          --name $CONTAINER_NAME \
          --account-name $STORAGE_ACCOUNT \
          --account-key $STORAGE_KEY

        # Upload the VHD file
        az storage blob upload \
          --account-name $STORAGE_ACCOUNT \
          --container-name $CONTAINER_NAME \
          --name "azure.ufs.vhdf" \
          --file "$(Pipeline.Workspace)/azure.ufs.vhdf" \
          --type page \
          --account-key $STORAGE_KEY

        # Create the image gallery if it doesn't exist
        az sig create \
          --resource-group $RESOURCE_GROUP \
          --gallery-name $GALLERY_NAME

        # Create the image definition if it doesn't exist
        az sig image-definition create \
          --resource-group $RESOURCE_GROUP \
          --gallery-name $GALLERY_NAME \
          --gallery-image-definition $IMAGE_DEFINITION \
          --publisher "$PUBLISHER" \
          --offer "$OFFER" \
          --sku "$SKU" \
          --os-type Linux

        # Create the image version
        az sig image-version create \
          --resource-group $RESOURCE_GROUP \
          --gallery-name $GALLERY_NAME \
          --gallery-image-definition $IMAGE_DEFINITION \
          --gallery-image-version $IMAGE_VERSION \
          --os-vhd-uri "https://$STORAGE_ACCOUNT.blob.core.windows.net/$CONTAINER_NAME/azure.ufs.vhdf" \
          --os-vhd-storage-account $STORAGE_ACCOUNT \
          --location $LOCATION \
          --replica-count 1 \
          --storage-account-type Standard_LRS

        # Expose variables to the next job
        echo "##vso[task.setvariable variable=RESOURCE_GROUP;isoutput=true]$RESOURCE_GROUP"
        echo "##vso[task.setvariable variable=GALLERY_NAME;isoutput=true]$GALLERY_NAME"
        echo "##vso[task.setvariable variable=IMAGE_DEFINITION;isoutput=true]$IMAGE_DEFINITION"
        echo "##vso[task.setvariable variable=IMAGE_VERSION;isoutput=true]$IMAGE_VERSION"
        echo "##vso[task.setvariable variable=LOCATION;isoutput=true]$LOCATION"
      displayName: 'Upload image and set variables'
      name: uploadImage

- job: CreateAndTestVM
  displayName: 'Create and Test VM'
  dependsOn: Upload_Image_to_Azure_Community_Gallery
  pool:
    vmImage: 'ubuntu-latest'
  variables:
    RESOURCE_GROUP: $[ dependencies.Upload_Image_to_Azure_Community_Gallery.outputs['uploadImage.RESOURCE_GROUP'] ]
    GALLERY_NAME: $[ dependencies.Upload_Image_to_Azure_Community_Gallery.outputs['uploadImage.GALLERY_NAME'] ]
    IMAGE_DEFINITION: $[ dependencies.Upload_Image_to_Azure_Community_Gallery.outputs['uploadImage.IMAGE_DEFINITION'] ]
    IMAGE_VERSION: $[ dependencies.Upload_Image_to_Azure_Community_Gallery.outputs['uploadImage.IMAGE_VERSION'] ]
    LOCATION: $[ dependencies.Upload_Image_to_Azure_Community_Gallery.outputs['uploadImage.LOCATION'] ]
  steps:
    - script: |
        # Generate a random 5-letter string
        RANDOM_GUID=$(cat /dev/urandom | tr -dc 'a-z' | fold -w 5 | head -n 1)
        VM_NAME="TestVM-$IMAGE_VERSION-$RANDOM_GUID"

        # Display all the variables set in the pipeline
        echo "RESOURCE_GROUP: $RESOURCE_GROUP"
        echo "GALLERY_NAME: $GALLERY_NAME"
        echo "IMAGE_DEFINITION: $IMAGE_DEFINITION"
        echo "IMAGE_VERSION: $IMAGE_VERSION"
        echo "LOCATION: $LOCATION"
        echo "VM_NAME: $VM_NAME"

        # Ensure variables are not empty
        if [ -z "$RESOURCE_GROUP" ]; then echo "RESOURCE_GROUP is empty"; exit 1; fi
        if [ -z "$GALLERY_NAME" ]; then echo "GALLERY_NAME is empty"; exit 1; fi
        if [ -z "$IMAGE_DEFINITION" ]; then echo "IMAGE_DEFINITION is empty"; exit 1; fi
        if [ -z "$IMAGE_VERSION" ]; then echo "IMAGE_VERSION is empty"; exit 1; fi
        if [ -z "$LOCATION" ]; then echo "LOCATION is empty"; exit 1; fi

        # Create the VM
        az vm create \
          --resource-group $RESOURCE_GROUP \
          --name $VM_NAME \
          --image $RESOURCE_GROUP/$GALLERY_NAME/$IMAGE_DEFINITION/$IMAGE_VERSION \
          --admin-username azureuser \
          --generate-ssh-keys \
          --location $LOCATION

        # Run a test command on the VM
        az vm run-command invoke \
          --resource-group $RESOURCE_GROUP \
          --name $VM_NAME \
          --command-id RunShellScript \
          --scripts "echo 123"

        # Delete the VM
        az vm delete \
          --resource-group $RESOURCE_GROUP \
          --name $VM_NAME \
          --yes
      displayName: 'Create VM, Run Test Command, and Delete VM'