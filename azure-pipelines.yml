trigger:
- main

# Define a parameter for the architecture
parameters:
- name: arch
  displayName: 'Architecture'
  type: string
  default: 'amd64'
  values:
    - 'amd64'
    - 'arm'
    - 'arm64'
    - 'i386'
    - 'powerpc'
    - 'powerpc64'
    - 'powerpc64le'
    - 'riscv'

variables:
  buildId: $(Build.BuildId)  # Assign the build ID to a variable

jobs:
- job: Build_OS_Image
  displayName: 'Build OS Image Job'
  timeoutInMinutes: 0  # Set global timeout to unlimited
  pool:
    name: BSD-Pool

  steps:
  - script: |
      sudo cp -v -R $(Build.SourcesDirectory)/** /usr/src
    displayName: 'Copy source code to /usr/src'

  # Set the architecture-specific variables directly in the steps
  - script: |
      TARGET_ARCH="amd64"  # Default
      if [[ '${{ parameters.arch }}' == 'amd64' ]]; then
        TARGET_ARCH="amd64"
      elif [[ '${{ parameters.arch }}' == 'arm' ]]; then
        TARGET_ARCH="armv7"
      elif [[ '${{ parameters.arch }}' == 'arm64' ]]; then
        TARGET_ARCH="aarch64"
      elif [[ '${{ parameters.arch }}' == 'i386' ]]; then
        TARGET_ARCH="i386"
      elif [[ '${{ parameters.arch }}' == 'powerpc' ]]; then
        TARGET_ARCH="powerpc"
      elif [[ '${{ parameters.arch }}' == 'powerpc64' ]]; then
        TARGET_ARCH="powerpc64"
      elif [[ '${{ parameters.arch }}' == 'powerpc64le' ]]; then
        TARGET_ARCH="powerpc64le"
      elif [[ '${{ parameters.arch }}' == 'riscv' ]]; then
        TARGET_ARCH="riscv64"
      fi
      
      # Export TARGET_ARCH as a pipeline variable for later steps
      echo "##vso[task.setvariable variable=TARGET_ARCH]$TARGET_ARCH"

      # Run the build with the resolved TARGET and TARGET_ARCH
      #sudo make -j$(sysctl -n kern.smp.cpus) -DWITHOUT_CLEAN=yes TARGET=${{ parameters.arch }} TARGET_ARCH=$TARGET_ARCH buildworld buildkernel
    displayName: 'Build world and kernel'

  - script: |
      # Build Azure image
      cd /usr/src/release
      sudo make CLOUDWARE=AZURE -DWITH_CLOUDWARE TARGET=${{ parameters.arch }} TARGET_ARCH=$TARGET_ARCH cw-azure
    displayName: 'Build Azure image'

  - task: PublishPipelineArtifact@1
    inputs:
      targetPath: '/usr/obj/usr/src/${{ parameters.arch }}.$(TARGET_ARCH)/release/azure.ufs.vhdf'
      artifactName: 'azure-image'
      publishLocation: 'pipeline'
    displayName: 'Publish Azure image artifact'

- job: Upload_Image_to_Azure_Community_Gallery
  displayName: 'Upload image to Azure Community Image Gallery'
  pool:
    vmImage: 'ubuntu-latest'
  steps:
    - script: |
        # Your existing script to upload the image
        az sig image-version create \
          --resource-group $RESOURCE_GROUP \
          --gallery-name $GALLERY_NAME \
          --gallery-image-definition $IMAGE_DEFINITION \
          --gallery-image-version $IMAGE_VERSION \
          --os-vhd-uri "https://$STORAGE_ACCOUNT.blob.core.windows.net/$CONTAINER_NAME/azure.ufs.vhdf" \
          --os-vhd-storage-account $STORAGE_ACCOUNT \
          --location $LOCATION \
          --replica-count 1 \
          --storage-account-type Standard_LRS

        # Expose variables to the next job
        echo "##vso[task.setvariable variable=RESOURCE_GROUP;isoutput=true]$RESOURCE_GROUP"
        echo "##vso[task.setvariable variable=GALLERY_NAME;isoutput=true]$GALLERY_NAME"
        echo "##vso[task.setvariable variable=IMAGE_DEFINITION;isoutput=true]$IMAGE_DEFINITION"
        echo "##vso[task.setvariable variable=IMAGE_VERSION;isoutput=true]$IMAGE_VERSION"
        echo "##vso[task.setvariable variable=LOCATION;isoutput=true]$LOCATION"
      displayName: 'Upload image and set variables'

- job: CreateAndTestVM
  displayName: 'Create and Test VM'
  dependsOn: Upload_Image_to_Azure_Community_Gallery
  pool:
    vmImage: 'ubuntu-latest'
  variables:
    RESOURCE_GROUP: $[ dependencies.Upload_Image_to_Azure_Community_Gallery.outputs['RESOURCE_GROUP'] ]
    GALLERY_NAME: $[ dependencies.Upload_Image_to_Azure_Community_Gallery.outputs['GALLERY_NAME'] ]
    IMAGE_DEFINITION: $[ dependencies.Upload_Image_to_Azure_Community_Gallery.outputs['IMAGE_DEFINITION'] ]
    IMAGE_VERSION: $[ dependencies.Upload_Image_to_Azure_Community_Gallery.outputs['IMAGE_VERSION'] ]
    LOCATION: $[ dependencies.Upload_Image_to_Azure_Community_Gallery.outputs['LOCATION'] ]
  steps:
    - script: |
        # Generate a random 5-letter string
        RANDOM_GUID=$(cat /dev/urandom | tr -dc 'a-z' | fold -w 5 | head -n 1)
        VM_NAME="TestVM-$IMAGE_VERSION-$RANDOM_GUID"

        # Display all the variables set in the pipeline
        echo "RESOURCE_GROUP: $RESOURCE_GROUP"
        echo "GALLERY_NAME: $GALLERY_NAME"
        echo "IMAGE_DEFINITION: $IMAGE_DEFINITION"
        echo "IMAGE_VERSION: $IMAGE_VERSION"
        echo "LOCATION: $LOCATION"
        echo "VM_NAME: $VM_NAME"

        # Ensure variables are not empty
        if [ -z "$RESOURCE_GROUP" ]; then echo "RESOURCE_GROUP is empty"; exit 1; fi
        if [ -z "$GALLERY_NAME" ]; then echo "GALLERY_NAME is empty"; exit 1; fi
        if [ -z "$IMAGE_DEFINITION" ]; then echo "IMAGE_DEFINITION is empty"; exit 1; fi
        if [ -z "$IMAGE_VERSION" ]; then echo "IMAGE_VERSION is empty"; exit 1; fi
        if [ -z "$LOCATION" ]; then echo "LOCATION is empty"; exit 1; fi

        # Create the VM
        az vm create \
          --resource-group $RESOURCE_GROUP \
          --name $VM_NAME \
          --image $RESOURCE_GROUP/$GALLERY_NAME/$IMAGE_DEFINITION/$IMAGE_VERSION \
          --admin-username azureuser \
          --generate-ssh-keys \
          --location $LOCATION

        # Run a test command on the VM
        az vm run-command invoke \
          --resource-group $RESOURCE_GROUP \
          --name $VM_NAME \
          --command-id RunShellScript \
          --scripts "echo 123"

        # Delete the VM
        az vm delete \
          --resource-group $RESOURCE_GROUP \
          --name $VM_NAME \
          --yes
      displayName: 'Create VM, Run Test Command, and Delete VM'